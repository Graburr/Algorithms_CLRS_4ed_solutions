Exercise page 15.

1.2-1)

It could be an application like booking. When you search a hotel close to the airport,
it gets involved algorithms as searching the hotels close to that airport and it should
be search in a short time of period.


1.2-2) 

Note: lg n --> log base 2 of n

8n^2 < 64n * lg n; n < 8 * lg n; (Try values until this ecuation is false)
To n ~= 43 insertion sort runs faster than merge sort.


1.2-3) 

100n^2 < 2^n; Trying values, for n < 15 (aprox) 100n^2 runs faster than 2^n.


2.1-1)

Note: Resolved using notation of C, C++, Java, etc.

a) [31, 41, 59, 26, 41, 58] i = 1

b) [31, 41, 59, 26, 41, 58] i = 2

c) [26, 31, 41, 59, 41, 58] i = 3 (31, 41 and 59 moved 1 position to the right and 26 
                                   inserted on the first position)
d) [26, 31, 41, 41, 59, 58] i = 4 (59 moved 1 position to right and 41 one position to left)

e) [26, 31, 41, 41, 58, 59] i = 5 (59 moved 1 position to right and 58 one to the left)


2.1-2)

Initialization: The loop start getting the first number in the array. In spite of that, 
it has initialized to 0 the variable sum where the total sum will be stored. Due to that,
the invariant holds the first number that will be added to sum.

Maintenance: On each iteration, the loop will hold only the index of the number that will
be added, after add it, i will be incremented by 1, holding the next number (i + 1).

Termination: The loop will terminate when the 'n' elements of the array are added. In conclusion,
sum it's equivalent of say that is the sumatory from i = 1 (first element) to n (last element) 
of A[i]. Sum contains all values in the array added to it.


2.1-3)

Resolved in the file "2.1-3.cpp"


2.1-4)


Linear-Search(A, n, x)
  for i = 1 to n 
    if (A[i] == x)
      return i

  return NIL


Initialization: The loop start getting the first element of the array. 

Maintenance: On each iteration, the loop takes the next element (i + 1) and compare it
with the value being search (x). If it's found return i, else, continue searching that value.

Termination: When all values are read, if x wasn't found in the array, it returns NIL to
indicate that no value was found on all the array.


2.1-5)

ADD-BINARY-INTEGERS(A, B, n)
  // Initialize array C with n values
  carry = 0

  for i to n
    c = A[i] + B[i]

    C[i] = c % 2
    carry = c // 2 (integer division)

  C[n] = carry
  return C


Initialization: The loop starts with value of carry to 0, and getting the first bits of 
A and B.

Maintenance: On each iteration, the loop takes the next bits values of A and B. Add these
values and calculate the value to insert into C and the carry that could exists.

Termination: All values were added and store, now C[0:n - 1] with the result of the sum.
To reach the n-th value, adds the last carry value on the position n.


Exercises page 33:

2.2-1)

Like the book says, theta-notation is like saying "roughly proportional to n2 when n is large."
In this case we remove constants so the remaining is n^3 + n^2 + n + 3. In this case the
value who has bigger exponent is n^3, so in any moment n^3 >>>> n^2 >>>> n. 
The solution is theta(n^3). 


2.2-2)

SELECTION-SORT(A, n)
  for i = 1 to n - 1
    ind_small_elm = i

    for j = i + 1 to n
      if A[ind_small_elm] < A[j]
        ind_small_elm = j

    swap(A[i], A[ind_small_elm])


The invairant is that on each iteration of extern for, it only takes 1 by 1 element. In the
inner for, also take all elemnts from i to n, and compare the value of the outter for
against the inner for to take the smaller elemnt.

Because when the algorithm arrives to the last element, all swaps ocurred and the last
element it will be sorted.

The worst case happens when it must iterate on the outher for and also with al the elements
from i to n in the inner for. So it's: n * n / 2 (avoding all constants). Thats mean that
theta=(n^2).

The best case is not better because you have to check all values in the if, the only instruction
that is avoided is the instruction inside the if because the if won't be evaluated to true.
But that instruction is insignificant if n it's too big.


2.2-3)

Depends on the value where is storage, if the x value is storage at the first position it
will take a constant value to search it. However, if the value is in the last element 
(worst case) it will spend constant * n time to find that value.

Averege case is suposing that it's in the middle of the array. The averegage is n / 2 = n
if n it's too big. 

Worst case as mentioned before is theta(n).


2.2-4)

The only thing you could do is a preprocessing step to check if it's alredy sorted or nearly
to be sorted and then apply the algorithm who best fits when the best case was achieved.