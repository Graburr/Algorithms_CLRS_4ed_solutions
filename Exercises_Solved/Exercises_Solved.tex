\documentclass{article}
\usepackage[utf8]{inputenc}
\usepackage{amsmath, amssymb, amsthm}
\usepackage{graphicx, float}
\usepackage{hyperref}
\usepackage[dvipsnames]{xcolor}
\usepackage{algorithm}
\usepackage[noend]{algpseudocode}
\graphicspath{{../Images/}}

% Customization of the document
\usepackage[letterpaper, top=1.8cm, bottom=2.3cm, left=2cm, right=2cm, heightrounded]{geometry}

% Line height
\renewcommand{\baselinestretch}{1.15}

% Define the exercise counter
\newcounter{exercise}[section]   % Resets the counter every time you change the section

% Format of exercise number (e.g., 1.1-1, 1.1-2, ...)
\renewcommand{\theexercise}{\thesection.\arabic{exercise}}

% Parskip and parindent
\setlength{\parindent}{0pt}
\setlength{\parskip}{0.8em}

\title{Exercise of Getting Started}
\author{Grabur}
\date{Feb 2025}

\begin{document}

\maketitle

\section{Chapter 1: Foundations}

\subsection{The Role of Algorithms in Computing}
I didn't make the exercise of this section because I didn't find them useful.

\subsection{Getting Started}
\setcounter{exercise}{0} % Start from 0 for the exercises in this section

% Used to make a label for referencing later if it's necesary
\refstepcounter{exercise}
\textbf{Exercise 1.2-1)}:\\
It could be an application like booking. When you search a hotel close to the airport, 
it gets involved algorithms as searching the hotels close to that airport and it should be
searched in a short time period.

\refstepcounter{exercise}
\textbf{Exercise 1.2-2)}:\\
\begin{flalign*}
    8n^2 < 64n \cdot \log_2 n \quad \rightarrow \quad n < 8 \cdot \log_2 n
\end{flalign*}
Try values until this inequality is false. To $n \lessapprox 43$, insertion sort runs 
faster than merge sort.

\refstepcounter{exercise}
\textbf{Exercise 1.2-3)}:\\
\begin{flalign*}
    100n^2 < 2^n \quad 
\end{flalign*}
Trying values, for $n \lessapprox 15$, $2^n$ runs faster than $100n^2$.

\refstepcounter{exercise}
\textbf{Exercise 1.2-4)}:\\
\\
\textit{\large View photo of the exercise on the next page.}
\newpage
\begin{figure*}[h]
    \includegraphics[scale=0.5]{Problem1_1}
    \centering
\end{figure*}


\refstepcounter{exercise}
\textbf{Exercise 2.1-1)}:\\
Note: Resolved using the logic of C, C++, Java, etc. while iterating over an array on a for
loop. Also the number that appears in \textcolor{ForestGreen}{green}, is the number being 
checked. The number or numbers that appears in \textcolor{Red}{red} are the numbers being 
moved.

\begin{center}
    \begin{tabular}{|c|c|}
    \hline
    \textbf{i} & \textbf{Array} \\
    \hline
    1) & [31, \textcolor{ForestGreen}{41}, 59, 26, 41, 58]\\
    2) & [31, 41, \textcolor{ForestGreen}{59}, 26, 41, 58]\\
    3) & [\textcolor{ForestGreen}{26}, \textcolor{Red}{31}, \textcolor{Red}{41}, 
          \textcolor{Red}{59}, 41, 58]\\
    4) & [26, 31, 41, \textcolor{ForestGreen}{41}, \textcolor{Red}{59}, 58]\\
    5) & [26, 31, 41, 41, \textcolor{ForestGreen}{58}, \textcolor{Red}{59}]\\
    \hline
    \end{tabular}
\end{center}

\refstepcounter{exercise}
\textbf{Exercise 2.1-2)}:\\
\textbf{Initialization}: The loop start getting the first number in the array. In spite of 
that, it has initialized to 0 the variable sum where the total sum will be stored. Due to 
that, the invariant holds the first number that will be added to sum.

\textbf{Maintenance}: On each iteration, the loop will hold only the index of the number 
that will be added, after add it, i will be incremented by 1, holding the next number (i + 1).

\textbf{Termination}: The loop will terminate when the 'n' elements of the array are added. In conclusion,
sum it's equivalent of say that $sum = \sum_{i = 1}^{n} A[i]$.
    
\refstepcounter{exercise}
\textbf{Exercise 2.1-3)}:\\
click this link to see the resolution \(\rightarrow \href{https://github.com/Graburr/Algorithms_CLRS_4ed_solutions/blob/main/chapter1/Getting_Started/2.1-3.cpp}
{\textcolor{blue}{resolution}}\)

\refstepcounter{exercise}
\textbf{Exercise 2.1-4)}:\\
\begin{algorithm}
\caption{Linear Search}\label{linearSearchID}
\begin{algorithmic}[1]
\Function{Linear-Search}{$A, n, x$}
    \For{$i \gets 1$ \textbf{to} $n$}
        \If {$ A[i] == x $} 
            \Return $i$
        \EndIf
    \EndFor
    \State \Return \textit{NIL}
\EndFunction
\end{algorithmic}
\end{algorithm}

\textbf{Initialization}: The loop start getting the first element of the array. 

\textbf{Maintenance}: On each iteration, the loop takes the next element (i + 1) and compare 
it with the value being search (x). If it's found return i, else, continue searching that 
value.

\textbf{Termination}: When all values are read, if x wasn't found in the array, it returns
NIL to indicate that no value was found on all the array.

\refstepcounter{exercise}
\textbf{Exercise 2.1-5)}:\\
\begin{algorithm}
\caption{ADD-BINARY-INTEGERS}\label{AddBinarySearchID}
\begin{algorithmic}[1]
\Function{ADD-BINARY-INTEGERS}{$A, B, n$}
    \State \textit{//Initialize array C with n values}
    \State \textit{carry} $\gets 0$ 
    \For {$i \gets 1$ \textbf{to} $n$}
        \State $c \gets A[i] + B[i]$
        \State $C[i] \gets c \mod 2$
        \State $carry \gets c \div 2$ \quad \textit{//Integer division}
    \EndFor
    \Statex
    \State $C[n] \gets carry$
    \State \Return \textit{C} \quad \textit{//Return the array C with the values}
\EndFunction
\end{algorithmic}
\end{algorithm}

\textbf{Initialization}: The loop starts with value of carry to 0, and getting the first 
bits of A and B.

\textbf{Maintenance}: On each iteration, the loop takes the next bits values of A and B.
Add these values and calculate the value to insert into C and the carry that could exists.

\textbf{Termination}: All values were added and store, now C[0:n - 1] with the result of 
the sum. To reach the n-th value, adds the last carry value on the position n.

\refstepcounter{exercise}
\textbf{Exercise 2.2-1)}:\\
Like the book says, \(\Theta\) notation is like saying "roughly proportional to \(n^2\) (for example), 
when \(n\) is large." In this case, we remove constants, so the remaining expression is 
\(n^3 + n^2 + n + 3\). The term with the highest exponent is \(n^3\), so at any moment:
\(n^3 \gg n^2 \gg n\). \\ 
\textbf{Solution}: \(\Theta(n^3)\).

\refstepcounter{exercise}
\textbf{Exercise 2.2-2)}:\\
\begin{algorithm}
\caption{SELECTION-SORT}\label{SelectionSortID}
\begin{algorithmic}[1]
\Function{SELECTION-SORT}{$A, n$}
    \For{$i \gets 1$ \textbf{to} $n - 1$}
        \State $ind\_small\_elm \gets i$
        \For{$j \gets i + 1$ \textbf{to} $n$}
            \If{$A[ind\_small\_elm] > A[j]$}
                \State $ind\_small\_elm \gets j$
            \EndIf
        \EndFor
        \State \Call{swap}{$A[i], A[ind\_small\_elm]$}
    \EndFor
\EndFunction
\end{algorithmic}
\end{algorithm}

The invairant is that on each iteration of extern for, it only takes 1 by 1 element. In the
inner for, also take all elemnts from i to n, and compare the value of the outter for
against the inner for to take the smaller elemnt.

When the algorithm arrives to the last element, all swaps ocurred and the last element will
be in the correct place.

The worst case happens when it must iterate on the outher for and also with al the elements
from i to n in the inner for. So it's: \(\frac{n*(n - 1)}{2}\). Thats mean that avoiding all
constants values, the solution is: \(\Theta(n^2)\).

The best case is not better because you have to check all values in the if, the only instruction
that is avoided is the instruction inside the if because the if won't be evaluated to true.
But that instruction is insignificant if \(n\) it's too big.

\refstepcounter{exercise}
\textbf{Exercise 2.2-3)}:\\
Depends on the value where is storage, if the \(x\) value is storage at the first position it
will take a constant value to search it. However, if the value is in the last element 
(worst case) it will spend \(constant * n\) time to find that value.

Averege case is suposing that it's in the middle of the array. The averegage is \(\frac{n}{2} = n\)
if \(n\) it's too big. 

Worst case as mentioned before is \(\Theta(n)\).

\refstepcounter{exercise}
\textbf{Exercise 2.2-3)}:\\
The only thing you could do is a preprocessing step to check if it's alredy sorted or nearly
to be sorted and then apply the algorithm who best fits when the best case was achieved.

\refstepcounter{exercise}
\textbf{Exercise 2.3-1)}:\\
\begin{figure*}[h]
    \includegraphics[scale=0.4]{Problem2_3_1.jpeg}
    \centering
\end{figure*}
\newpage

\refstepcounter{exercise}
\textbf{Exercise 2.3-2)}:\\
The "\textit{\textbf{if} \(p \neq r\)}" is not useful because \(p = 1\) and \(q > 1\), so the if
will be evaluated to true, and the return (the termination of recursion) will execute without
doing any recursion step.

\refstepcounter{exercise}
\textbf{Exercise 2.3-3)}:\\
\textbf{Initialization}: The loop starts obtaning the first element to insert it in the 
sorted array.

\textbf{Maintenance}: On each iteration, the loop insert 1 element of the left or right array,
then increment \textit{k} by 1, to insert on the next iteration the next value 1 by 1. The values
that will be inserted with the first loop in the best case is \textit{n - 1} where n is the
lenght of the subarray/array being sorted.

\textbf{Termination}: In one of the last 2 whiles, it will be inserted all remaining values
(could be values in the left or right array) until reach the nth values in the sorted array.

\refstepcounter{exercise}
\textbf{Exercise 2.3-4)}:\\
\textit{n = 2}
\[
T(2) = 2
\]
The solution given says that:
\[
T(2) = 2 * \log_2 2 = 2 \cdot 1 = 2
\]
Induction hypotesis:
\[
T(k) = k \cdot \log_2 k
\]
Where k is a power of 2. We want to demostrate that \textit{n = 2k}.
Use recurrence to calculate \(T(2k)\):
\[
T(2k) = 2T(k) + 2k \quad \rightarrow \quad T(2k) = 2 \cdot (k * \log_2 k) + 2k \quad \rightarrow
\quad T(2k) = 2k \cdot (\log_2 k + 1) \quad \rightarrow \quad T(2k) = 2k \cdot \log_2 2k
\]
As we mentiones before, replacing \textit{n = 2k}, we conclude that the induction hypotesis
is correct \textbf{\(n \cdot \log_2 n\)}

\refstepcounter{exercise}
\textbf{Exercise 2.3-5)}:
\begin{algorithm}
    \caption{INSERTION-SORT-RECURSIVE}\label{InsertionSortRecursiveID}
    \begin{algorithmic}[1]
        \Function{INSERTION-SORT-RECURSIVE}{$A, n$}
            \If{\(n == 0\)}  
                \Return
            \EndIf
            \State \Call{INSERTION-SORT-RECURSIVE}{$A, n - 1$}
            \State \textit{key} $\gets$ \textit{A[n]}
            \State $i \gets n - 1$
            \While {$i \geq 0$ \textbf{and} $A[i] > key$}
                \State $A[i + 1] \gets A[i]$
                \State $i \gets i - 1$
            \EndWhile
            \State $A[i + 1] \gets key$
        \EndFunction
    \end{algorithmic}
\end{algorithm}

\newpage
\refstepcounter{exercise}
\textbf{Exercise 2.3-6)}:
\begin{algorithm}
    \caption{BINARY-SEARCH}\label{BinarySearchID}
    \begin{algorithmic}[1]
        \Function{BinarySearch}{$A, x, l, n$}
            \If {\(l > n\)}
                \Return
            \EndIf
            \State \textit{mid} \(\gets\) \(l + n / 2\)
            \If {\(A[mid] > x\)}
                \State \Call{BinarySearch}{$A, x, l, mid - 1$}
            \ElsIf {\(A[mid] < x\)}
                \State \Call{BinarySearch}{$A, x, mid + 1, r$}
            \Else 
                \quad \Return \textit{mid}
            \EndIf
        \EndFunction
    \end{algorithmic}
\end{algorithm}

\refstepcounter{exercise}
\textbf{Exercise 2.3-7)}:
You can't use binary search because while you are sorting most part of the time, it won't
be that value in the sorted array. Maybe you should make a variation of binary search to 
find out in which direction has less difference betwen the number being search and then
you should move all values 1 position to right and insert in the new position.

On worst case, imagine that the worst value is at the least position, you should move
n items to the right + n / 2 that cost to search all the. So it's  \(n \cdot \frac{n}{2} = \Theta(n^2)\)

\refstepcounter{exercise}
\textbf{Exercise 2.3-8)}:
\begin{algorithm}
    \caption{FIND-SUM-TWO-ELEMENTS}\label{FindSumTwoElementsID}
    \begin{algorithmic}[1]
        \Function{FindSumTwoElements}{$S, n, x$}
            \State \Call{MergeSort}{S, 0, n - 1} \quad \textit{//\(\Theta(n * log n)\)}
            \State \( i \gets 0 \)
            \State \( j \gets n - 1 \)
            \While {\( i < j \)} \quad \textit{//\(\Theta(n)\)}
                \If {\( S[i] + S[j] = x \)}
                    \State \Return \( i, j \)
                \ElsIf {\( S[i] + S[j] < x \)}
                    \State \( i \gets i + 1 \)
                \Else
                    \State \( j \gets j - 1 \)
                \EndIf
            \EndWhile
            \State \Return \textit{No pair found}
        \EndFunction
    \end{algorithmic}
\end{algorithm}





\end{document}
